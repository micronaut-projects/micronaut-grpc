=== Writing a Simple GRPC Server

To implement a GRPC server for the previously defined `helloworld.proto` definition you first need to generate the Java stubs using Gradle or Maven then create a class that extends from `GreeterGrpc.GreeterImplBase`.

For example:

.GreeterGrpc.GreeterImplBase Example
[source,java]
----
include::examples/hello-world-java/src/main/java/helloworld/GreetingEndpoint.java[tags=imports]

include::examples/hello-world-java/src/main/java/helloworld/GreetingEndpoint.java[tags=clazz]
----

<1> The class extends from `GreeterGrpc.GreeterImplBase` and is annotated with `javax.inject.Singleton`
<2> You can dependency inject other beans into the implementation. In this case `GreetingService` is dependency injected.
<3> The `StreamObserver` is used to send a response to the client.

=== Running the GRPC Server

To run the server use the `Application` class or run `./gradlew run` for Gradle or `./mvnw compile exec:exec` for Maven.


The server by default runs on port 50051, however you can configure which port the server runs on by setting `grpc.server.port` to whichever value you wish (a value of -1 will use a random port).

=== Configuring the GRPC Server

The server can be be configured in a number of different ways. You can use the `io.micronaut.grpc.server.GrpcServerConfiguration` type to configure any property of GRPC's `NettyServerBuilder` class via `application.yml`.

For example:

.Configuring the GRPC server
[source,yaml]
----
grpc:
    server:
        port: 8080
        keep-alive-time: 3h
        max-inbound-message-size: 1024
        cert-chain: '/path/to/my.cert'
        private-key: '/path/to/my.key'
----

Alternatively if you prefer programmatic configuration you can write a `BeanCreationListener` for example:

.Configuring the ServerBuilder
[source,java]
----
include::grpc-runtime/src/test/groovy/io/micronaut/grpc/ServerBuilderListener.java[]
----

=== Auto Injected Types

By default the server will automatically be dependency injected with beans of the following types:

* `io.grpc.BindableService` - Any services declared as beans
* `io.grpc.ServerInterceptor` - Any interceptors declared as beans
* `io.grpc.ServerTransportFilter` - Any transport filters declared as beans

In addition, by default the server will be setup to use Micronaut's I/O executor service.

=== Testing the Server

To test the server it is recommended that you use https://github.com/micronaut-projects/micronaut-test[Micronaut Test].

TIP: For detailed instructions on how to setup Micronaut Test for either Spock or JUnit 5 see the https://micronaut-projects.github.io/micronaut-test/latest/guide/index.html[documentation] on the subject.


You can then define a blocking stub bean in `src/test/java`. For example:

.Defining Test Clients
[source,java]
----
include::examples/hello-world-java/src/test/java/helloworld/GreetingEndpointTest.java[tags=clients]
----

<1> A `ManagedChannel` is injected that can communicate with the server.
<2> The generated GRPC client blocking stub is created.

The above example uses the `@GrpcChannel` annotation to inject a GRPC `ManagedChannel` that can communicate with the running server. This channel will be automatically be shutdown when the application shuts down.

Now that you have a test client, writing the test becomes trivial:

.Writing a Test
[source,java]
----
include::examples/hello-world-java/src/test/java/helloworld/GreetingEndpointTest.java[tags=imports]

include::examples/hello-world-java/src/test/java/helloworld/GreetingEndpointTest.java[tags=test]
----

<1> The test is annotated with `@MicronautTest`
<2> The client stub is injected into the test
<3> A request is sent and the response asserted.